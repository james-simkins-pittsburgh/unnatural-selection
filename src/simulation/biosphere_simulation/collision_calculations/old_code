use crate::{
    settings::GameSettings,
    simulation::{
        biosphere_simulation::blob_mover::CollisionCheckResult,
        AllSpatialBiosphereInformation,
        CircleEntityType,
        CirclePositionRecord,
    },
    utility_functions::{
        deterministic_trigonometry::DeterministicTrig,
        integer_math::square_root_64,
        quadratic_solver,
        two_circles_intersection_solver::solve_two_circle_intersection,
    },
};

use super::GRID_SIZE;

// This stores the circle information for the colliders.
struct ColliderCircleInfo {
    x: i32,
    y: i32,
    radius: i32,
    distance_to_center_of_mass: i32,
    angle_to_center_of_mass: i32,
}

pub fn detect_collision(
    all_spatial_biosphere_information: &AllSpatialBiosphereInformation,
    blob_number: usize,
    game_settings: &GameSettings,
    deterministic_trig: &DeterministicTrig
) -> CollisionCheckResult {
    let mut collider_circles: Vec<ColliderCircleInfo> = Vec::new();

    // This makes a vec of all the circles of the collider blob.
    for organism_number in all_spatial_biosphere_information.blob_vec[blob_number].blob_members.iter() {
        collider_circles.push(ColliderCircleInfo {
            x: all_spatial_biosphere_information.organism_information_vec[*organism_number].x_location,
            y: all_spatial_biosphere_information.organism_information_vec[*organism_number].y_location,
            radius: all_spatial_biosphere_information.organism_information_vec[*organism_number].radius,
            distance_to_center_of_mass: all_spatial_biosphere_information.organism_information_vec
                [*organism_number].distance_from_center_of_mass,
            angle_to_center_of_mass: all_spatial_biosphere_information.organism_information_vec
                [*organism_number].angle_to_center_of_mass,
        });

        if all_spatial_biosphere_information.organism_information_vec[*organism_number].oblong {
            for circle in all_spatial_biosphere_information.organism_information_vec[
                *organism_number
            ].other_circle_positions.iter() {
                collider_circles.push(ColliderCircleInfo {
                    x: circle.x,
                    y: circle.y,
                    radius: circle.radius,
                    distance_to_center_of_mass: all_spatial_biosphere_information.organism_information_vec
                        [*organism_number].distance_from_center_of_mass,
                    angle_to_center_of_mass: all_spatial_biosphere_information.organism_information_vec
                        [*organism_number].angle_to_center_of_mass,
                });
            }
        }
    }

    // Send all the circles to the helper function to work out what, if anything, collides first
    // Then send the results back to the blob mover.
    return check_circles(
        collider_circles,
        &all_spatial_biosphere_information,
        &game_settings,
        blob_number,
        deterministic_trig
    );
}

// This helper function consults the detection grid to determine if any collisions will occur with the movement of the blob.
fn check_circles(
    collider_circles: Vec<ColliderCircleInfo>,
    all_spatial_biosphere_information: &AllSpatialBiosphereInformation,
    game_settings: &GameSettings,
    blob_number: usize,
    deterministic_trig: &DeterministicTrig
) -> CollisionCheckResult {
    // These store the maximum movement before a collision (if any) occurs.
    let mut x_move = all_spatial_biosphere_information.blob_vec[blob_number].blob_x_velocity;
    let mut y_move = all_spatial_biosphere_information.blob_vec[blob_number].blob_y_velocity;
    let mut r_move = all_spatial_biosphere_information.blob_vec[blob_number].angular_velocity;

    // This stores the original moves so it can be references later.
    let original_x_move = x_move;
    let original_y_move = y_move;

    // This is a list of all involved blobs so calculations can be done to get new velocities after a collision.
    let mut involved_blobs = vec![blob_number];

    // This keeps track if a mineral is involved. If one is, then the entire collision will result in 0 velocities.
    let mut involved_minerals = false;
    // Iterates over every collider circle.
    for collider_circle in collider_circles.iter() {
        // If the only movement is rotational, this can all be skipped.
        if x_move != 0 && y_move != 0 {
            // Iterates over every collidee circle in the detection grid.
            for collidee_circle in all_spatial_biosphere_information.collision_detection_grid[
                ((collider_circle.x + game_settings.map_length / 2) / GRID_SIZE) as usize
            ][((collider_circle.y + game_settings.map_height / 2) / GRID_SIZE) as usize].iter() {
                // This function checks if the two circle collide and determined how much x and y movement occurs before that.
                check_two_circles_translational(
                    &mut x_move,
                    &mut y_move,
                    original_x_move,
                    original_y_move,
                    &mut involved_blobs,
                    &mut involved_minerals,
                    blob_number,
                    collider_circle,
                    collidee_circle
                );
            }

            /* I THINK THERE IS A LOGIC ERROR HERE. NEEDS TO CONSIDER POTENTIAL COLLIDEE SIZE AS WELL AS X_MOVE AND Y_MOVE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */

            // This checks to see if the grid to the right needs to be checked.

            if
                (collider_circle.x + collider_circle.radius + game_settings.map_length / 2) /
                    GRID_SIZE != (collider_circle.x + game_settings.map_length / 2) / GRID_SIZE &&
                (collider_circle.x + collider_circle.radius + game_settings.map_length / 2) /
                    GRID_SIZE < (all_spatial_biosphere_information.collision_detection_grid.len() as i32)
            {
                for collidee_circle in all_spatial_biosphere_information.collision_detection_grid[
                    ((collider_circle.x + collider_circle.radius + game_settings.map_length / 2) /
                        GRID_SIZE) as usize
                ][
                    ((collider_circle.y + game_settings.map_height / 2) / GRID_SIZE) as usize
                ].iter() {
                    // This function checks if the two circle collide and determined how much x and y movement occurs before that.
                    check_two_circles_translational(
                        &mut x_move,
                        &mut y_move,
                        original_x_move,
                        original_y_move,
                        &mut involved_blobs,
                        &mut involved_minerals,
                        blob_number,
                        collider_circle,
                        collidee_circle
                    );
                }
            }

            // This checks to see if the grid to the left to be checked.

            if
                (collider_circle.x - collider_circle.radius + game_settings.map_length / 2) /
                    GRID_SIZE != (collider_circle.x + game_settings.map_length / 2) / GRID_SIZE &&
                (collider_circle.x - collider_circle.radius + game_settings.map_length / 2) /
                    GRID_SIZE >= 0
            {
                for collidee_circle in all_spatial_biosphere_information.collision_detection_grid[
                    ((collider_circle.x - collider_circle.radius + game_settings.map_length / 2) /
                        GRID_SIZE) as usize
                ][
                    ((collider_circle.y + game_settings.map_height / 2) / GRID_SIZE) as usize
                ].iter() {
                    // This function checks if the two circle collide and determined how much x and y movement occurs before that.
                    check_two_circles_translational(
                        &mut x_move,
                        &mut y_move,
                        original_x_move,
                        original_y_move,
                        &mut involved_blobs,
                        &mut involved_minerals,
                        blob_number,
                        collider_circle,
                        collidee_circle
                    );
                }
            }

            // This checks to see if the grid above needs to be checked.

            if
                (collider_circle.y + collider_circle.radius + game_settings.map_height / 2) /
                    GRID_SIZE != (collider_circle.y + game_settings.map_height / 2) / GRID_SIZE &&
                (collider_circle.y + collider_circle.radius + game_settings.map_height / 2) /
                    GRID_SIZE < (all_spatial_biosphere_information.collision_detection_grid[0].len() as i32)
            {
                for collidee_circle in all_spatial_biosphere_information.collision_detection_grid[
                    ((collider_circle.x + game_settings.map_length / 2) / GRID_SIZE) as usize
                ][
                    ((collider_circle.y + collider_circle.radius + game_settings.map_height / 2) /
                        GRID_SIZE) as usize
                ].iter() {
                    // This function checks if the two circle collide and determined how much x and y movement occurs before that.
                    check_two_circles_translational(
                        &mut x_move,
                        &mut y_move,
                        original_x_move,
                        original_y_move,
                        &mut involved_blobs,
                        &mut involved_minerals,
                        blob_number,
                        collider_circle,
                        collidee_circle
                    );
                }

                // This checks to see if the grid above and to the right needs to be checked.

                if
                    (collider_circle.x + collider_circle.radius + game_settings.map_length / 2) /
                        GRID_SIZE !=
                        (collider_circle.x + game_settings.map_length / 2) / GRID_SIZE &&
                    (collider_circle.x + collider_circle.radius + game_settings.map_length / 2) /
                        GRID_SIZE <
                        (all_spatial_biosphere_information.collision_detection_grid.len() as i32)
                {
                    for collidee_circle in all_spatial_biosphere_information.collision_detection_grid[
                        ((collider_circle.x +
                            collider_circle.radius +
                            game_settings.map_length / 2) /
                            GRID_SIZE) as usize
                    ][
                        ((collider_circle.y +
                            collider_circle.radius +
                            game_settings.map_height / 2) /
                            GRID_SIZE) as usize
                    ].iter() {
                        // This function checks if the two circle collide and determined how much x and y movement occurs before that.
                        check_two_circles_translational(
                            &mut x_move,
                            &mut y_move,
                            original_x_move,
                            original_y_move,
                            &mut involved_blobs,
                            &mut involved_minerals,
                            blob_number,
                            collider_circle,
                            collidee_circle
                        );
                    }
                }

                // This checks to see if the grid above and to the left needs to be checked.

                if
                    (collider_circle.x - collider_circle.radius + game_settings.map_length / 2) /
                        GRID_SIZE !=
                        (collider_circle.x + game_settings.map_length / 2) / GRID_SIZE &&
                    (collider_circle.x - collider_circle.radius + game_settings.map_length / 2) /
                        GRID_SIZE >= 0
                {
                    for collidee_circle in all_spatial_biosphere_information.collision_detection_grid[
                        ((collider_circle.x -
                            collider_circle.radius +
                            game_settings.map_length / 2) /
                            GRID_SIZE) as usize
                    ][
                        ((collider_circle.y +
                            collider_circle.radius +
                            game_settings.map_height / 2) /
                            GRID_SIZE) as usize
                    ].iter() {
                        // This function checks if the two circle collide and determined how much x and y movement occurs before that.
                        check_two_circles_translational(
                            &mut x_move,
                            &mut y_move,
                            original_x_move,
                            original_y_move,
                            &mut involved_blobs,
                            &mut involved_minerals,
                            blob_number,
                            collider_circle,
                            collidee_circle
                        );
                    }
                }
            }

            // This checks to see if the grid below needs to be checked.

            if
                (collider_circle.y - collider_circle.radius + game_settings.map_height / 2) /
                    GRID_SIZE != (collider_circle.y + game_settings.map_height / 2) / GRID_SIZE &&
                (collider_circle.y + collider_circle.radius + game_settings.map_height / 2) /
                    GRID_SIZE >= 0
            {
                for collidee_circle in all_spatial_biosphere_information.collision_detection_grid[
                    ((collider_circle.x + game_settings.map_length / 2) / GRID_SIZE) as usize
                ][
                    ((collider_circle.y - collider_circle.radius + game_settings.map_height / 2) /
                        GRID_SIZE) as usize
                ].iter() {
                    // This function checks if the two circle collide and determined how much x and y movement occurs before that.
                    check_two_circles_translational(
                        &mut x_move,
                        &mut y_move,
                        original_x_move,
                        original_y_move,
                        &mut involved_blobs,
                        &mut involved_minerals,
                        blob_number,
                        collider_circle,
                        collidee_circle
                    );
                }

                // This checks to see if the grid below and to the right needs to be checked.

                if
                    (collider_circle.x + collider_circle.radius + game_settings.map_length / 2) /
                        GRID_SIZE !=
                        (collider_circle.x + game_settings.map_length / 2) / GRID_SIZE &&
                    (collider_circle.x + collider_circle.radius + game_settings.map_length / 2) /
                        GRID_SIZE <
                        (all_spatial_biosphere_information.collision_detection_grid.len() as i32)
                {
                    for collidee_circle in all_spatial_biosphere_information.collision_detection_grid[
                        ((collider_circle.x +
                            collider_circle.radius +
                            game_settings.map_length / 2) /
                            GRID_SIZE) as usize
                    ][
                        ((collider_circle.y -
                            collider_circle.radius +
                            game_settings.map_height / 2) /
                            GRID_SIZE) as usize
                    ].iter() {
                        // This function checks if the two circle collide and determined how much x and y movement occurs before that.
                        check_two_circles_translational(
                            &mut x_move,
                            &mut y_move,
                            original_x_move,
                            original_y_move,
                            &mut involved_blobs,
                            &mut involved_minerals,
                            blob_number,
                            collider_circle,
                            collidee_circle
                        );
                    }
                }

                // This checks to see if the grid below and to the left needs to be checked.

                if
                    (collider_circle.x - collider_circle.radius + game_settings.map_length / 2) /
                        GRID_SIZE !=
                        (collider_circle.x + game_settings.map_length / 2) / GRID_SIZE &&
                    (collider_circle.x - collider_circle.radius + game_settings.map_length / 2) /
                        GRID_SIZE >= 0
                {
                    for collidee_circle in all_spatial_biosphere_information.collision_detection_grid[
                        ((collider_circle.x -
                            collider_circle.radius +
                            game_settings.map_length / 2) /
                            GRID_SIZE) as usize
                    ][
                        ((collider_circle.y -
                            collider_circle.radius +
                            game_settings.map_height / 2) /
                            GRID_SIZE) as usize
                    ].iter() {
                        // This function checks if the two circle collide and determined how much x and y movement occurs before that.
                        check_two_circles_translational(
                            &mut x_move,
                            &mut y_move,
                            original_x_move,
                            original_y_move,
                            &mut involved_blobs,
                            &mut involved_minerals,
                            blob_number,
                            collider_circle,
                            collidee_circle
                        );
                    }
                }
            }
        }

        // Rotational movement only happens if the full translational movement is completed.

        if r_move != 0 && x_move == original_y_move && y_move == original_y_move {
            // Store the new collider x and y after full rotation.
            let full_collider_x =
                all_spatial_biosphere_information.blob_vec[blob_number].center_of_mass_x +
                x_move +
                (collider_circle.distance_to_center_of_mass *
                    deterministic_trig.d_trig.cosine((r_move, 1000)).0) /
                    1000;
            let full_collider_y =
                all_spatial_biosphere_information.blob_vec[blob_number].center_of_mass_y +
                y_move +
                (collider_circle.distance_to_center_of_mass *
                    deterministic_trig.d_trig.sine((r_move, 1000)).0) /
                    1000;

            // LEFT OFF HERE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        }
    }

    let collision: bool;

    // If there are involved blobs other than the blob, then a collision must have happened.
    if involved_blobs.len() > 1 || involved_minerals == true {
        collision = true;
    } else {
        collision = false;
    }

    return CollisionCheckResult {
        collision,
        x_move,
        y_move,
        r_move,
        involved_blobs,
        involved_minerals,
    };
}